        -- CenterTargetingSystem.lua
-- A targeting system with a circular reticle and mobile support
-- Place this in StarterPlayerScripts

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Configuration
local config = {
    Enabled = true,              -- Is the system enabled by default
    ToggleKey = Enum.KeyCode.F,  -- Key to toggle the system on/off (PC)
    MaxDistance = 100,           -- Maximum distance to target
    FieldOfView = 40,            -- Field of view in degrees (how far from center targets can be)
    TeamCheck = true,            -- Check if target is on same team
    VisibilityCheck = true,      -- Check if target is visible (not behind walls)
    TargetPart = "HumanoidRootPart", -- Part to target (Head, HumanoidRootPart, etc.)
    SmoothingFactor = 0.2,       -- How smoothly to track targets (0-1, lower = smoother)
    AssistStrength = 0.6,        -- How strong the assist is (0-1, higher = stronger)
    
    -- Circle reticle settings
    CircleRadius = 12,           -- Size of the targeting circle
    CircleThickness = 2,         -- Thickness of the circle line
    DefaultColor = Color3.fromRGB(255, 255, 255), -- Default white circle
    TargetColor = Color3.fromRGB(255, 0, 0),      -- Red when targeting
    CircleTransparency = 0,      -- 0 = fully visible, 1 = invisible
    CircleFilled = false,        -- Whether the circle is filled or just an outline
    PulseEffect = true,          -- Whether the circle should pulse when locked on target
    PulseSpeed = 1,              -- Speed of the pulse effect
    PulseSize = 1.5,             -- Maximum size multiplier for pulse effect
    
    -- Mobile button settings
    MobileButtonSize = UDim2.new(0, 50, 0, 50),    -- Size of the mobile toggle button
    MobileButtonPosition = UDim2.new(0.9, -25, 0.7, -25), -- Position (right side, medium height)
    MobileButtonColor = Color3.fromRGB(200, 200, 200),  -- Button color when off
    MobileButtonActiveColor = Color3.fromRGB(0, 200, 0), -- Button color when on
    MobileButtonTransparency = 0.3,                 -- Button transparency
    MobileButtonIcon = "rbxassetid://6031625146"    -- Target icon (change to any Roblox asset ID)
}

-- Variables
local targetedPlayer = nil
local isAiming = false
local isTargetingEnabled = config.Enabled
local isMobile = GuiService:IsTenFootInterface() or UserInputService.TouchEnabled

-- Create the targeting UI with center-fixed circle
local function createTargetingUI()
    local targetGui = Instance.new("ScreenGui")
    targetGui.Name = "TargetingSystem"
    targetGui.ResetOnSpawn = false
    targetGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Make sure GUI works in Core and PlayerGui
    if syn and syn.protect_gui then
        syn.protect_gui(targetGui)
        targetGui.Parent = game.CoreGui
    else
        targetGui.Parent = player:WaitForChild("PlayerGui")
    end
    
    -- Create the circle reticle (fixed in center)
    local circleFrame = Instance.new("Frame")
    circleFrame.Name = "CircleReticle"
    circleFrame.Size = UDim2.new(0, config.CircleRadius * 2, 0, config.CircleRadius * 2)
    circleFrame.Position = UDim2.new(0.5, -config.CircleRadius, 0.5, -config.CircleRadius)
    circleFrame.AnchorPoint = Vector2.new(0, 0)
    circleFrame.BackgroundTransparency = 1
    circleFrame.Visible = isTargetingEnabled
    circleFrame.Parent = targetGui
    
    -- Create the actual circle using UIStroke (for outline)
    local circleStroke = Instance.new("UIStroke")
    circleStroke.Thickness = config.CircleThickness
    circleStroke.Color = config.DefaultColor
    circleStroke.Transparency = config.CircleTransparency
    circleStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    circleStroke.Parent = circleFrame
    
    -- Create a UICorner to make the frame circular
    local circleCorner = Instance.new("UICorner")
    circleCorner.CornerRadius = UDim.new(1, 0) -- Makes it a perfect circle
    circleCorner.Parent = circleFrame
    
    -- If filled, configure background
    if config.CircleFilled then
        circleFrame.BackgroundColor3 = config.DefaultColor
        circleFrame.BackgroundTransparency = config.CircleTransparency + 0.5 -- Make fill more transparent than outline
    end
    
    -- Create mobile toggle button if on mobile/touch device
    local toggleButton
    if isMobile then
        toggleButton = Instance.new("ImageButton")
        toggleButton.Name = "ToggleButton"
        toggleButton.Size = config.MobileButtonSize
        toggleButton.Position = config.MobileButtonPosition
        toggleButton.AnchorPoint = Vector2.new(0.5, 0.5)
        toggleButton.BackgroundColor3 = isTargetingEnabled and config.MobileButtonActiveColor or config.MobileButtonColor
        toggleButton.BackgroundTransparency = config.MobileButtonTransparency
        toggleButton.Image = config.MobileButtonIcon
        toggleButton.ImageTransparency = 0.1
        toggleButton.Parent = targetGui
        
        -- Add rounded corners to the button
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(1, 0) -- Makes it a circle
        buttonCorner.Parent = toggleButton
        
        -- Add a UI stroke to make it more visible
        local buttonStroke = Instance.new("UIStroke")
        buttonStroke.Thickness = 2
        buttonStroke.Color = Color3.fromRGB(0, 0, 0)
        buttonStroke.Transparency = 0.3
        buttonStroke.Parent = toggleButton
        
        -- Add text label inside button to show status
        local statusLabel = Instance.new("TextLabel")
        statusLabel.Name = "StatusLabel"
        statusLabel.Size = UDim2.new(1, 0, 0.3, 0)
        statusLabel.Position = UDim2.new(0, 0, 0.85, 0)
        statusLabel.BackgroundTransparency = 1
        statusLabel.Text = isTargetingEnabled and "ON" or "OFF"
        statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        statusLabel.TextStrokeTransparency = 0
        statusLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        statusLabel.TextScaled = true
        statusLabel.Font = Enum.Font.GothamBold
        statusLabel.Parent = toggleButton
        
        -- Toggle button click handler
        toggleButton.MouseButton1Click:Connect(function()
            isTargetingEnabled = not isTargetingEnabled
            toggleButton.BackgroundColor3 = isTargetingEnabled and config.MobileButtonActiveColor or config.MobileButtonColor
            statusLabel.Text = isTargetingEnabled and "ON" or "OFF"
            circleFrame.Visible = isTargetingEnabled
            
            -- Provide feedback
            local feedbackText = isTargetingEnabled and "Targeting ON" or "Targeting OFF"
            game.StarterGui:SetCore("SendNotification", {
                Title = "Targeting System",
                Text = feedbackText,
                Duration = 1
            })
        end)
    end
    
    return {
        TargetGui = targetGui,
        CircleFrame = circleFrame,
        CircleStroke = circleStroke,
        ToggleButton = toggleButton
    }
end

-- Create UI elements
local ui = createTargetingUI()

-- Toggle system on key press (for PC)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- Toggle with keyboard (for PC)
    if input.KeyCode == config.ToggleKey then
        isTargetingEnabled = not isTargetingEnabled
        ui.CircleFrame.Visible = isTargetingEnabled
        
        -- Update button visuals if on mobile
        if ui.ToggleButton then
            ui.ToggleButton.BackgroundColor3 = isTargetingEnabled and config.MobileButtonActiveColor or config.MobileButtonColor
            ui.ToggleButton:FindFirstChild("StatusLabel").Text = isTargetingEnabled and "ON" or "OFF"
        end
        
        -- Provide feedback
        game.StarterGui:SetCore("SendNotification", {
            Title = "Targeting System",
            Text = isTargetingEnabled and "Targeting ON" or "Targeting OFF",
            Duration = 1
        })
    end
    
    -- Check for aiming (right mouse button for PC, or touch hold for mobile)
    if input.UserInputType == Enum.UserInputType.MouseButton2 or 
       (isMobile and input.UserInputType == Enum.UserInputType.Touch) then
        isAiming = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 or 
       (isMobile and input.UserInputType == Enum.UserInputType.Touch) then
        isAiming = false
        -- Don't hide the circle, just reset its color
        ui.CircleStroke.Color = config.DefaultColor
        if config.CircleFilled then
            ui.CircleFrame.BackgroundColor3 = config.DefaultColor
        end
    end
end)

-- Function to check if a position is within the circle reticle
local function isInCircle(screenPosition)
    local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - screenCenter).Magnitude
    
    return distance <= config.CircleRadius
end

-- Function to check if target is visible
local function isVisible(target)
    if not config.VisibilityCheck then return true end
    
    local character = player.Character
    if not character then return false end
    
    local rayOrigin = character:FindFirstChild("Head") and character.Head.Position or character:FindFirstChild("HumanoidRootPart").Position
    local rayDirection = target.Position - rayOrigin
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character, target.Parent}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult == nil
end

-- Function to check if player is valid target
local function isValidTarget(targetPlayer)
    if targetPlayer == player then return false end
    
    local targetCharacter = targetPlayer.Character
    if not targetCharacter then return false end
    
    local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
    if not targetHumanoid or targetHumanoid.Health <= 0 then return false end
    
    local targetPart = targetCharacter:FindFirstChild(config.TargetPart)
    if not targetPart then return false end
    
    -- Check distance
    local character = player.Character
    if not character then return false end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    local distance = (rootPart.Position - targetPart.Position).Magnitude
    if distance > config.MaxDistance then return false end
    
    -- Check if target is in the center circle
    local screenPosition = camera:WorldToScreenPoint(targetPart.Position)
    if screenPosition.Z < 0 then return false end -- Behind camera
    
    if not isInCircle(screenPosition) then return false end
    
    -- Check visibility
    if not isVisible(targetPart) then return false end
    
    -- Team check
    if config.TeamCheck and targetPlayer.Team == player.Team then return false end
    
    return true
end

-- Find the best target
local function findTarget()
    local closestDistance = math.huge
    local closestPlayer = nil
    
    for _, targetPlayer in pairs(Players:GetPlayers()) do
        if isValidTarget(targetPlayer) then
            local targetCharacter = targetPlayer.Character
            local targetPart = targetCharacter:FindFirstChild(config.TargetPart)
            
            -- Calculate screen position
            local screenPoint = camera:WorldToScreenPoint(targetPart.Position)
            local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
            local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
            
            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = targetPlayer
            end
        end
    end
    
    return closestPlayer
end

-- Update pulse animation for the circle
local pulseTime = 0
local function updatePulseEffect(hasTarget)
    if not config.PulseEffect then return end
    
    if hasTarget then
        pulseTime = pulseTime + RunService.RenderStepped:Wait() * config.PulseSpeed
        local pulseScale = 1 + ((math.sin(pulseTime) + 1) / 2) * (config.PulseSize - 1)
        
        -- Apply the pulse scale to the circle size
        local newSize = config.CircleRadius * 2 * pulseScale
        ui.CircleFrame.Size = UDim2.new(0, newSize, 0, newSize)
        ui.CircleFrame.Position = UDim2.new(0.5, -newSize/2, 0.5, -newSize/2)
    else
        -- Reset to default size when not targeting
        ui.CircleFrame.Size = UDim2.new(0, config.CircleRadius * 2, 0, config.CircleRadius * 2)
        ui.CircleFrame.Position = UDim2.new(0.5, -config.CircleRadius, 0.5, -config.CircleRadius)
    end
end

-- Update camera to target
RunService.RenderStepped:Connect(function()
    if not isTargetingEnabled then
        targetedPlayer = nil
        ui.CircleFrame.Visible = false
        return
    else
        ui.CircleFrame.Visible = true
    end
    
    local character = player.Character
    if not character then return end
    
    -- Find target (only when aiming)
    if isAiming then
        targetedPlayer = findTarget()
    else
        targetedPlayer = nil
    end
    
    -- Apply aim assist if we have a target
    if targetedPlayer and isAiming then
        local targetCharacter = targetedPlayer.Character
        local targetPart = targetCharacter:FindFirstChild(config.TargetPart)
        
        -- Change color when locked on target
        ui.CircleStroke.Color = config.TargetColor
        if config.CircleFilled then
            ui.CircleFrame.BackgroundColor3 = config.TargetColor
        end
        
        -- Update pulse effect
        updatePulseEffect(true)
        
        -- Calculate target camera CFrame
        local targetCFrame = CFrame.new(camera.CFrame.Position, targetPart.Position)
        
        -- Smoothly interpolate camera rotation
        local currentCFrame = camera.CFrame
        local newCFrame = currentCFrame:Lerp(targetCFrame, config.SmoothingFactor * config.AssistStrength)
        
        -- Apply the new camera orientation
        camera.CFrame = newCFrame
    else
        -- Reset circle color when not targeting
        ui.CircleStroke.Color = config.DefaultColor
        if config.CircleFilled then
            ui.CircleFrame.BackgroundColor3 = config.DefaultColor
        end
        
        -- Reset pulse
        updatePulseEffect(false)
    end
end)

-- Create a small text label to indicate status on startup (will fade out)
local function showStartupMessage()
    local message = Instance.new("TextLabel")
    message.Name = "StartupMessage"
    message.Size = UDim2.new(0, 300, 0, 50)
    message.Position = UDim2.new(0.5, -150, 0.8, -25)
    message.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    message.BackgroundTransparency = 0.3
    message.Text = isMobile and "Targeting System: Use button to toggle" or "Targeting System: Press F to toggle"
    message.TextColor3 = Color3.fromRGB(255, 255, 255)
    message.TextSize = 18
    message.Font = Enum.Font.GothamBold
    message.Parent = ui.TargetGui
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 10)
    corner.Parent = message
    
    -- Fade out after 5 seconds
    spawn(function()
        wait(3)
        for i = 0, 1, 0.05 do
            message.BackgroundTransparency = 0.3 + (i * 0.7)
            message.TextTransparency = i
            wait(0.05)
        end
        message:Destroy()
    end)
end

showStartupMessage()
